generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  providerId String?  @unique
  name      String?
  displayName String?
  image     String?
  role      UserRole @default(MEMBER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // relations
  squads     SquadMember[]
  absences   Absence[]
  assignments Assignment[]
  sprintMembers SprintMember[]
  dayAllocations DayAllocation[]
  auditLogs  AuditLog[]
  tickets    Ticket[]
}

enum UserRole {
  ADMIN
  SCRUM_MASTER
  MEMBER
}

model Squad {
  id        String   @id @default(uuid())
  alias     String   @unique
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  scrumMasterId String

  // Ceremony defaults (in minutes/hours as specified)
  dailyScrumMinutes     Int     @default(15)    // Default: 15 minutes
  refinementHours       Float   @default(1.0)   // Default: 1 hour per week
  reviewDemoMinutes     Int     @default(30)    // Default: 30 minutes per sprint
  planningHours         Float   @default(1.0)   // Default: 1 hour per week
  retrospectiveMinutes  Int     @default(30)    // Default: 30 minutes per week

  members   SquadMember[]
  sprints   Sprint[]
  holidays  Holiday[]
  invitations Invitation[]
}

model SquadMember {
  id        String @id @default(uuid())
  squad     Squad  @relation(fields: [squadId], references: [id])
  squadId   String
  user      User   @relation(fields: [userId], references: [id])
  userId    String
  createdAt DateTime @default(now())
}

model Sprint {
  id        String      @id @default(uuid())
  name      String
  startDate DateTime
  endDate   DateTime
  status    SprintStatus @default(INACTIVE)
  isActive  Boolean     @default(false) // For capacity planning - determines if sprint appears in capacity plans
  squadId   String
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  squad     Squad         @relation(fields: [squadId], references: [id])
  members   SprintMember[]
  tickets   Ticket[]
  capacityTickets CapacityTicket[] // NEW: Jira tickets for capacity planning
  absences  Absence[]
  assignments Assignment[]

  @@unique([squadId, name]) // Prevent duplicate sprint names within squad
}

enum SprintStatus {
  ACTIVE
  INACTIVE
  COMPLETED
}

enum WorkType {
  BACKEND
  FRONTEND
  TESTING
}

enum ParentType {
  BUG
  STORY
  TASK
}

enum PlannedUnplanned {
  PLANNED
  UNPLANNED
}

model SprintMember {
  id        String   @id @default(uuid())
  sprintId  String
  userId    String
  createdAt DateTime @default(now())

  sprint    Sprint @relation(fields: [sprintId], references: [id])
  user      User   @relation(fields: [userId], references: [id])

  @@unique([sprintId, userId]) // User can only be in sprint once
}

model Holiday {
  id        String @id @default(uuid())
  squad     Squad  @relation(fields: [squadId], references: [id])
  squadId   String
  date      DateTime
  description String?
}

model Absence {
  id        String @id @default(uuid())
  user      User   @relation(fields: [userId], references: [id])
  userId    String
  sprint    Sprint @relation(fields: [sprintId], references: [id])
  sprintId  String
  startDate DateTime
  endDate   DateTime
  hours     Float
  type      AbsenceType
}

enum AbsenceType {
  VACATION
  SICK
  TRAINING
  OTHER
}

model Ticket {
  id              String           @id @default(uuid())
  jiraId          String
  hours           Float
  workType        WorkType
  parentType      ParentType
  plannedUnplanned PlannedUnplanned
  memberId        String?
  sprintId        String
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  // relations
  sprint          Sprint           @relation(fields: [sprintId], references: [id])
  member          User?            @relation(fields: [memberId], references: [id])
  assignments     Assignment[]

  @@unique([sprintId, jiraId]) // Prevent duplicate jiraId within same sprint
}

model CapacityTicket {
  id          String   @id @default(cuid())
  title       String
  description String?
  status      String   // e.g., "To Do", "In Progress", "Done"
  assignee    String?  // User name or email
  jiraKey     String?  // JIRA-123 format
  sprintId    String
  sprint      Sprint   @relation(fields: [sprintId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([sprintId])
  @@map("capacity_tickets")
}

model Assignment {
  id        String @id @default(uuid())
  ticket    Ticket @relation(fields: [ticketId], references: [id])
  ticketId  String
  sprint    Sprint @relation(fields: [sprintId], references: [id])
  sprintId  String
  assignee  User?  @relation(fields: [assigneeId], references: [id])
  assigneeId String?
  hours     Float
  dayAllocations DayAllocation[]
}

model DayAllocation {
  id        String @id @default(uuid())
  date      DateTime
  user      User   @relation(fields: [userId], references: [id])
  userId    String
  hours     Float
  assignment Assignment? @relation(fields: [assignmentId], references: [id])
  assignmentId String?
}

model Invitation {
  id        String @id @default(uuid())
  email     String
  squad     Squad? @relation(fields: [squadId], references: [id])
  squadId   String?
  invitedRole UserRole?
  tokenHash String
  expiresAt DateTime
  status    InvitationStatus @default(PENDING)
  createdAt DateTime @default(now())
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  EXPIRED
}

model AuditLog {
  id        String   @id @default(uuid())
  actorId   String
  actor     User     @relation(fields: [actorId], references: [id])
  action    String
  meta      Json?
  createdAt DateTime @default(now())
}

model AccessRequest {
  id        String @id @default(uuid())
  email     String
  name      String?
  image     String?
  providerId String?
  requestedRole UserRole
  status    AccessRequestStatus @default(PENDING)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum AccessRequestStatus {
  PENDING
  APPROVED
  DECLINED
}
